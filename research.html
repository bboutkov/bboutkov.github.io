<!DOCTYPE html>
<html lang="en-US">

  <head>
    <title>Current Research</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="default.css">
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900" rel="stylesheet" />

    <!-- google analytics tracking -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143513927-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-143513927-1');
    </script>


    <!-- mathjax latex rendering -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

  </head>

  <body>

    <div id="page" class="container">

      <!-- Sidebar -->
      <div id="header">

        <div id="logo">
	  <img src="imgs/headshot.png" alt="" />
	  <h1><a href="contact.html">Boris Boutkov</a></h1>
	</div>

	<div id="menu">
	  <ul>
	    <li><a href="index.html" accesskey="1" title="">Homepage</a></li>
	    <li class="current_page_item"><a href="research.html" accesskey="2" title="">Recent Research</a></li>
	    <li><a href="past_projects.html" accesskey="3" title="">Past Projects</a></li>
	    <li><a href="cv.html" accesskey="4" title="">CV</a></li>
	    <li><a href="contact.html" accesskey="5" title="">Location and Contact</a></li>
	  </ul>
	</div>

        <div id="logo">
          <span>Last modified: June 24, 2019 </span>
	</div>

      </div>

      <!-- Content -->
      <div id="main">
        <div id="welcome">
          <div class="title">
            <h1>Geometric Multigrid Solver for Unstructured Finite Elements</h1>

            <br>
            <p align="left"> Recently I've spent good chunk of time
              implementing and studying the effecacy of utilizing
              geometric multigrid for solving partial differntial
              equations (PDEs) on unstructured grids.</p>

            <br>

            <p align="left"> Geometric Multigrid is particularly effective as its known
            to perform optimally as a black box PDE solver for elliptic PDEs. The
            technique operates by smoothing the solution on a series of coarser
            sub-problems whose information can then be used to repeatedly
            solve the originally desired fine grid problem in a highly
            efficient fashion. The method is algorithmically scaleable, and it
            converges to the solution in a fixed number of iterations that is
            independent of the mesh resolution.

            The key aspect and difficulty of such a technique is
            implementing it in an efficient, parallel manner which is
            independent of the input parameters. As such, much of the
            solver infrastructure was implemented in the open source
            libMesh library while examples of the optimality of the
            technique were demonstrated in the GRINS multiphysics
            application built on top of libMesh.

            We begin by defining a sequence of grids $\{G_i\}$, and we
            denote by $\#G_i$ the number of mesh elements within a
            given grid $G_i$. For simplicity we assume that these
            grids are ordered based on their element count so that we
            have: $\#G_f >... > \#G_i > ... > \#G_c$ where we adopt
            the notation so that $G_f$ and $G_c$ correspond
            respectively to the finest and coarsest grids. </p>

            <br>

            <p align="left"> libMesh is used to partition the domain amongst
            processors, refine the mesh, and then manage
            local-to-global degree of freedom information as well as
            ghosted element info which must be periodically
            communicated amongst processors.The multigrid technique
            then utilizes such info to construct a grid hierachy and
            projection and interpolation operators which become
            fundamental pieces to the overall algorithm. </p>

            <img src="imgs/partitioning_refinement.svg" alt="Partitioning and Refinement Example" width="600" align="center">


            <p align="left"> As a simple example of the solver in action we can
            consider a square domain with insulated boundaries which
            is forced internally with some heat source given by: </p>

            $$b(x) = 2\pi^2 \sin(\pi x)\sin(\pi y)$$.

            <p align="left"> This gives rise to a steady state
            solution as depicted in the following solution
            profile: </p>

            <br>

            <img src="imgs/forced_2d.svg" alt="2D Forced Poisson solution">

            <br>

            <p align="left"> As expected, this gives rise to optimal convergence rates
            which we can compute by comparing our computed solution to
            an exact solution generated via the method of manufactured
            solutions. </p>

            <img src="imgs/vcycle_vs_fmg.svg" alt="V cycles vs FMG convergence">

            <p align="left"> By changing a few runtime parameters from
            the command line we can instead solve a 3D problem where
            instead we heat one wall, insulate the rest of the faces,
            and upon solving the problem with multigrid we can recover
            the expected linear temperature gradient in a
            cross-section of the domain as presented below. </p>

            <img src="imgs/hotcold_3d.svg" alt="3D Poisson Solution with Hot-Cold Boundaries">

            <p align="left"> We can similarly study more exotic physics. For example here we
            consider thermally driven flow which utilizes a Boussinesq
            approximation to couple the energy balance equation to that of the
            incompressible Navier Stokes formulation discussed previouslly. In the
            figure below we can observe the formation of thermal vortices, a
            phenomena which is particularly difficult for black box solvers to
            resolve. </p>

            <img src="imgs/thermo_inc_ra1e6_temp.svg" alt="Thermally Coupled Flow Temperature Solution, Rayleigh number 1e6">

            <p align="left"> 2Of course there are many possible further applicatoins of
            such a technique which can be explored through the
            introduction of differnt domains, boundary conditions, and
            physics couplings. Having the ability to explore such
            scenarios from the command line provides a very fast and
            robust method for modeling and investigating the behaviour
            and dynamics of various problems of interest. </p>

          </div>

          <div id="copyright">
	    <span>&copy; Boris Boutkov 2019. All rights reserved. </span>
            <span>Hosted through <a href="https://pages.github.com/">github pages</a> </span>
          </div>

        </div>
      </div>

  </body>
</html>
